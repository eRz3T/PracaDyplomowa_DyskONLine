Struktura projektu sdrive

/controllers
	auth.js
{const express = require("express");
const register = require("./register");
const login = require("./login");
const { searchFriend, inviteFriend } = require('./friends');
const uploadFile = require("./upload");
const loggedIn = require("./loggedIn"); 

const router = express.Router();

router.post("/register", register);
router.post("/login", login);
router.post("/upload", loggedIn, uploadFile); 
router.post('/search-friend', loggedIn, searchFriend);
router.post('/invite-friend', loggedIn, inviteFriend);

module.exports = router;
}

	deleteFile.js
{const fs = require('fs');
const path = require('path');
const { dbFiles } = require('../routes/db-config');  // Połączenie z bazą danych

const deleteFile = (req, res) => {
    const safeId = req.user.safeid_users;  // Pobierz safeid użytkownika (cryptedowner_files)
    const filename = req.params.filename;  // Pobierz zaszyfrowaną nazwę pliku (cryptedname_files)
    const userDir = path.join(__dirname, '..', 'data', 'users', safeId);  // Folder użytkownika
    const filePath = path.join(userDir, filename);  // Ścieżka do pliku

    // Sprawdź, czy plik istnieje w systemie plików
    if (fs.existsSync(filePath)) {
        // Usuń plik z systemu plików
        fs.unlink(filePath, (err) => {
            if (err) {
                console.error('Błąd podczas usuwania pliku:', err);
                return res.json({ status: 'error', error: 'Błąd podczas usuwania pliku' });
            }

            // Usuń wpis z bazy danych na podstawie cryptedname_files i cryptedowner_files
            dbFiles.query(
                'DELETE FROM files WHERE cryptedname_files = ? AND cryptedowner_files = ?',
                [filename, safeId],
                (err, result) => {
                    if (err) {
                        console.error('Błąd podczas usuwania wpisu z bazy danych:', err);
                        return res.json({ status: 'error', error: 'Błąd podczas usuwania z bazy danych' });
                    }

                    console.log(`Plik ${filename} został pomyślnie usunięty z systemu plików i bazy danych.`);
                    return res.json({ status: 'success', success: 'Plik został usunięty' });
                }
            );
        });
    } else {
        console.log(`Plik ${filename} nie istnieje w ścieżce ${filePath}`);
        res.status(404).json({ status: 'error', error: 'Plik nie istnieje' });
    }
};

module.exports = deleteFile;
}

	download.js
{const fs = require('fs');
const path = require('path');
const { dbFiles } = require('../routes/db-config');  // Połączenie z bazą danych

const downloadFile = (req, res) => {
    const safeId = req.user.safeid_users;  // Pobierz safeid użytkownika (cryptedowner_files)
    const filename = req.params.filename;  // Pobieramy zaszyfrowaną nazwę pliku (cryptedname_files)

    // Pobierz plik z bazy danych na podstawie cryptedname_files i cryptedowner_files
    dbFiles.query(
        'SELECT originalname_files, cryptedname_files FROM files WHERE cryptedname_files = ? AND cryptedowner_files = ?',
        [filename, safeId],
        (err, result) => {
            if (err) {
                console.error('Błąd podczas pobierania pliku z bazy danych:', err);
                return res.status(500).json({ status: 'error', error: 'Błąd pobierania pliku' });
            }
            
            if (result.length > 0) {
                const originalName = result[0].originalname_files;
                const cryptedName = result[0].cryptedname_files;
                const userDir = path.join(__dirname, '..', 'data', 'users', safeId);  // Folder użytkownika
                const filePath = path.join(userDir, cryptedName);  // Ścieżka do pliku na podstawie cryptedname_files

                // Sprawdź, czy plik istnieje
                if (fs.existsSync(filePath)) {
                    res.download(filePath, originalName);  // Pobierz plik z oryginalną nazwą
                } else {
                    res.status(404).send("Plik nie istnieje");
                }
            } else {
                res.status(404).send("Plik nie istnieje w bazie danych");
            }
        }
    );
};

module.exports = downloadFile;
}

	fileController.js
{const fs = require('fs');
const path = require('path');
const mammoth = require('mammoth');
const { dbFiles } = require('../routes/db-config');

// Funkcja do wyświetlania zawartości pliku
const showFileContent = (req, res) => {
    const safeId = req.user.safeid_users;
    const filename = req.params.filename;

    dbFiles.query(
        'SELECT originalname_files, cryptedname_files, filetype_files FROM files WHERE cryptedname_files = ? AND cryptedowner_files = ?',
        [filename, safeId],
        (err, result) => {
            if (err) {
                console.error('Błąd podczas pobierania pliku z bazy danych:', err);
                return res.status(500).json({ status: 'error', error: 'Błąd pobierania pliku z bazy danych' });
            }

            if (result.length > 0) {
                const originalName = result[0].originalname_files;
                const fileExtension = path.extname(originalName).toLowerCase();
                const userDir = path.join(__dirname, '..', 'data', 'users', safeId);
                const filePath = path.join(userDir, filename);  // Plik przechowywany pod zaszyfrowaną nazwą

                if (fs.existsSync(filePath)) {
                    console.log(`Plik istnieje: ${filePath}`);

                    if (fileExtension === '.txt' || fileExtension === '.md') {
                        // Wyświetlanie plików tekstowych i .md
                        fs.readFile(filePath, 'utf8', (err, data) => {
                            if (err) {
                                console.error('Błąd podczas czytania pliku:', err);
                                return res.status(500).send("Błąd podczas czytania pliku");
                            }
                            res.json({ content: data.replace(/\n/g, '<br>'), originalName });
                        });

                    } else if (fileExtension === '.docx') {
                        // Konwersja pliku .docx na HTML za pomocą mammoth
                        mammoth.convertToHtml({ path: filePath })
                            .then(result => {
                                const htmlFilePath = path.join(userDir, `${path.basename(filename, '.docx')}.html`);
                                fs.writeFileSync(htmlFilePath, result.value);  // Zapisujemy plik .html na serwerze
                                console.log('Plik .docx został pomyślnie skonwertowany i zapisany jako .html.');
                                res.json({ content: result.value, originalName, htmlFilePath });
                            })
                            .catch(err => {
                                console.error('Błąd podczas konwersji pliku .docx:', err);
                                res.status(500).send("Błąd podczas konwersji pliku .docx");
                            });

                    } else {
                        res.status(400).send("Nieobsługiwany typ pliku");
                    }

                } else {
                    console.log(`Plik nie istnieje: ${filePath}`);
                    res.status(404).send("Plik nie istnieje");
                }
            } else {
                res.status(404).send("Plik nie istnieje w bazie danych");
            }
        }
    );
};

// Funkcja do usuwania plików HTML
const removeHtmlFile = (req, res) => {
    const { htmlFilePath } = req.body;

    if (fs.existsSync(htmlFilePath)) {
        fs.unlink(htmlFilePath, (err) => {
            if (err) {
                console.error('Błąd podczas usuwania pliku .html:', err);
                return res.json({ status: 'error', error: 'Błąd podczas usuwania pliku .html' });
            }
            console.log(`Plik .html został usunięty: ${htmlFilePath}`);
            res.json({ status: 'success', success: 'Plik .html został usunięty' });
        });
    } else {
        res.status(404).json({ status: 'error', error: 'Plik .html nie istnieje' });
    }
};

module.exports = {
    showFileContent,
    removeHtmlFile
};
}

	friends.js
{const bcrypt = require("bcryptjs");
const { dbLogins } = require('../routes/db-config');

// Wyszukiwanie użytkownika po emailu
const searchFriend = (req, res) => {
    const { email } = req.body;
    console.log(`Otrzymano żądanie wyszukania znajomego o emailu: ${email}`);

    dbLogins.query('SELECT id_users, email_users FROM users WHERE email_users = ?', [email], (err, result) => {
        if (err) {
            console.error('Błąd podczas wyszukiwania użytkownika w bazie danych:', err);
            return res.json({ status: 'error', error: 'Błąd wyszukiwania' });
        }

        if (result.length === 0) {
            console.log(`Nie znaleziono użytkownika o emailu: ${email}`);
            return res.json({ status: 'error', error: 'Użytkownik nie został znaleziony' });
        }

        console.log(`Znaleziono użytkownika: ${result[0].email_users}, ID: ${result[0].id_users}`);
        res.json({ status: 'success', user: result[0] });
    });
};

// Funkcja pobierająca listę aktywnych znajomych
const getFriends = (req, res) => {
    const userId = req.user.id_users;

    // Pobierz aktywnych znajomych
    dbLogins.query(`
        SELECT users.id_users, users.firstname_users, users.lastname_users, users.email_users
        FROM friends
        JOIN users ON (friends.id_user_1_friends = users.id_users OR friends.id_user_2_friends = users.id_users)
        WHERE (friends.id_user_1_friends = ? OR friends.id_user_2_friends = ?) 
        AND friends.status_friends = "Active" AND users.id_users != ?`,
        [userId, userId, userId], (err, results) => {
            if (err) {
                return res.json({ status: 'error', error: 'Błąd pobierania znajomych' });
            }
            console.log('Pobrano listę znajomych:', results); // Debug
            return res.json({ status: 'success', friends: results });
        }
    );
};


// Funkcja odpowiadająca na zaproszenie do znajomych (akceptacja/odmowa)
const respondToFriendRequest = (req, res) => {
    const { noteId, action } = req.body;
    
    // Ustaw status w zależności od działania
    let newStatus = '';
    if (action === 'accept') {
        newStatus = 'Active';
    } else if (action === 'deny') {
        newStatus = 'Denied';
    } else {
        return res.json({ status: 'error', error: 'Nieprawidłowa akcja' });
    }

    // Znajdź odpowiedni wpis w tabeli friends na podstawie kodu noteId
    dbLogins.query(
        'SELECT * FROM friends WHERE noteid_notifications_friends = ?',
        [noteId],
        (err, result) => {
            if (err) {
                return res.json({ status: 'error', error: 'Błąd podczas szukania zaproszenia' });
            }

            if (result.length === 0) {
                return res.json({ status: 'error', error: 'Nie znaleziono zaproszenia' });
            }

            const friendEntryId = result[0].id_friends;

            // Zaktualizuj status w tabeli friends
            dbLogins.query(
                'UPDATE friends SET status_friends = ? WHERE id_friends = ?',
                [newStatus, friendEntryId],
                (err, updateResult) => {
                    if (err) {
                        return res.json({ status: 'error', error: 'Błąd aktualizacji statusu' });
                    }

                    return res.json({ status: 'success', success: `Zaproszenie zostało ${action === 'accept' ? 'zaakceptowane' : 'odrzucone'}.` });
                }
            );
        }
    );
};

// Funkcja sprawdzająca unikalność kodu
const isNoteIdUnique = (noteId) => {
    return new Promise((resolve, reject) => {
        dbLogins.query('SELECT noteid_notifications_friends FROM friends WHERE noteid_notifications_friends = ?', [noteId], (err, result) => {
            if (err) reject(err);
            if (result.length > 0) {
                resolve(false);  // Kod nie jest unikalny
            } else {
                resolve(true);  // Kod jest unikalny
            }
        });
    });
};

// Funkcja sprawdzająca, czy użytkownicy są już znajomymi
const areUsersAlreadyFriends = (userId1, userId2) => {
    return new Promise((resolve, reject) => {
        dbLogins.query(
            'SELECT * FROM friends WHERE (id_user_1_friends = ? AND id_user_2_friends = ? OR id_user_1_friends = ? AND id_user_2_friends = ?) AND status_friends = "Active"',
            [userId1, userId2, userId2, userId1],
            (err, result) => {
                if (err) reject(err);
                if (result.length > 0) {
                    resolve(true);  // Użytkownicy są już znajomymi
                } else {
                    resolve(false); // Użytkownicy nie są znajomymi
                }
            }
        );
    });
};

// Funkcja wysyłająca zaproszenie do znajomych
const inviteFriend = async (req, res) => {
    const inviterId = req.user.id_users; // ID użytkownika zapraszającego
    const inviterEmail = req.user.email_users; // Email zapraszającego
    const { friendId } = req.body; // ID zaproszonego użytkownika

    // Sprawdź, czy użytkownicy nie są już znajomymi
    const alreadyFriends = await areUsersAlreadyFriends(inviterId, friendId);
    
    if (alreadyFriends) {
        return res.json({ status: 'error', error: 'Użytkownicy są już znajomymi.' });
    }

    // Znajdź safeid_users zapraszanego użytkownika
    dbLogins.query('SELECT safeid_users, email_users FROM users WHERE id_users = ?', [friendId], async (err, result) => {
        if (err) {
            return res.json({ status: 'error', error: 'Błąd wyszukiwania użytkownika' });
        }

        if (result.length === 0) {
            return res.json({ status: 'error', error: 'Nie znaleziono zapraszanego użytkownika' });
        }

        const recipientSafeId = result[0].safeid_users;
        const recipientEmail = result[0].email_users;

        // Pętla generująca unikalny kod bcrypt
        let noteId;
        let unique = false;
        
        while (!unique) {
            noteId = await bcrypt.hash(Date.now().toString(), 10);  // Generowanie kodu
            unique = await isNoteIdUnique(noteId);  // Sprawdzanie unikalności kodu
        }

        // Zapis zaproszenia do tabeli `friends`
        dbLogins.query(
            'INSERT INTO friends (id_user_1_friends, id_user_2_friends, status_friends, noteid_notifications_friends) VALUES (?, ?, "NotActive", ?)',
            [inviterId, friendId, noteId],
            (err, result) => {
                if (err) {
                    return res.json({ status: 'error', error: 'Błąd zaproszenia znajomego' });
                }

                // Tworzymy wiadomość dla powiadomienia
                const message = `Użytkownik ${req.user.firstname_users} ${req.user.lastname_users} (${inviterEmail}) wysłał ci zaproszenie do znajomych.`;

                // Zapis powiadomienia do tabeli `notifications`
                dbLogins.query(
                    'INSERT INTO notifications (user_notifications, head_notifications, msg_notifications, type_notifications, status_notifications, date_notifications, dispatcher_notifications, noteid_notifications) VALUES (?, "Zaproszenie do znajomych", ?, "friend_request", "unread", CURDATE(), ?, ?)',
                    [recipientSafeId, message, inviterEmail, noteId],
                    (err, result) => {
                        if (err) {
                            return res.json({ status: 'error', error: 'Błąd wysyłania powiadomienia' });
                        }
                        res.json({ status: 'success', success: 'Znajomy został zaproszony, a powiadomienie wysłane.' });
                    }
                );
            }
        );
    });
};

const removeFriend = (req, res) => {
    const { friendId } = req.body;
    const userEmail = req.user.email_users;  // Email użytkownika

    console.log('Próba usunięcia znajomego o ID:', friendId); // Debug

    // Znajdź ID użytkownika na podstawie emaila
    dbLogins.query('SELECT id_users FROM users WHERE email_users = ?', [userEmail], (err, result) => {
        if (err) {
            console.error('Błąd przy wyszukiwaniu użytkownika na podstawie emaila:', err);
            return res.json({ status: 'error', error: 'Błąd podczas wyszukiwania użytkownika.' });
        }

        if (result.length === 0) {
            return res.json({ status: 'error', error: 'Nie znaleziono użytkownika.' });
        }

        const userId = result[0].id_users;
        console.log('Zalogowany użytkownik ID:', userId); // Debug

        // Sprawdź, czy istnieje znajomość ze statusem "Active"
        dbLogins.query(`
            SELECT * FROM friends
            WHERE (id_user_1_friends = ? AND id_user_2_friends = ?) OR (id_user_1_friends = ? AND id_user_2_friends = ?) 
            AND status_friends = "Active"`,
            [userId, friendId, friendId, userId], (err, result) => {
                if (err) {
                    console.error('Błąd zapytania SQL przy sprawdzaniu znajomości:', err); // Debug
                    return res.json({ status: 'error', error: 'Błąd podczas sprawdzania znajomości.' });
                }

                console.log('Wynik zapytania sprawdzającego:', result); // Debug

                if (result.length === 0) {
                    return res.json({ status: 'error', error: 'Nie znaleziono aktywnej znajomości do usunięcia.' });
                }

                // Zaktualizuj status znajomości na "Removed"
                dbLogins.query(`
                    UPDATE friends
                    SET status_friends = "Removed"
                    WHERE (id_user_1_friends = ? AND id_user_2_friends = ?) OR (id_user_1_friends = ? AND id_user_2_friends = ?)
                    AND status_friends = "Active"`,
                    [userId, friendId, friendId, userId], (err, updateResult) => {
                        if (err) {
                            console.error('Błąd zapytania SQL przy usuwaniu znajomego:', err); // Debug
                            return res.json({ status: 'error', error: 'Błąd podczas usuwania znajomego.' });
                        }

                        console.log('Wynik zapytania SQL:', updateResult); // Debug

                        if (updateResult.affectedRows === 0) {
                            console.warn('Nie znaleziono aktywnej znajomości do usunięcia.'); // Debug
                            return res.json({ status: 'error', error: 'Nie znaleziono aktywnej znajomości.' });
                        }

                        console.log('Znajomy został pomyślnie usunięty.'); // Debug
                        return res.json({ status: 'success', success: 'Znajomy został usunięty.' });
                    }
                );
            }
        );
    });
};



module.exports = { searchFriend, inviteFriend, respondToFriendRequest, getFriends, removeFriend };
}

	loggedIn.js
{const { dbLogins } = require("../routes/db-config");
const jwt = require("jsonwebtoken");

const loggedIn = (req, res, next) => {
    if (!req.cookies.userRegistered) {
        console.log("Brak ciasteczka JWT");
        return next();
    }
    
    try {
        const decoded = jwt.verify(req.cookies.userRegistered, process.env.JWT_SECRET);
        console.log("Odczytany token JWT:", decoded);  // Dodaj logowanie

        dbLogins.query('SELECT * FROM users WHERE id_users = ?', [decoded.id], (err, result) => {
            if (err) throw err;
            if (result.length > 0) {
                req.user = result[0];
                console.log("Użytkownik rozpoznany:", req.user);  // Dodaj logowanie
                return next();
            } else {
                console.log("Użytkownik nie został znaleziony w bazie");
                return next();
            }
        });
    } catch (err) {
        console.log("Błąd JWT:", err);
        return next();
    }
};

module.exports = loggedIn;
}

	login.js
{const jwt = require("jsonwebtoken");
const { dbLogins } = require("../routes/db-config");
const bcryptjs = require("bcryptjs");

const login = async (req, res) => {
    const { email, password } = req.body;

    console.log("Odebrane dane logowania:", req.body);

    if (!email || !password) {
        return res.json({ status: "error", error: "Podaj swój email i hasło" });
    } else {
        dbLogins.query('SELECT email_users, password_users, id_users FROM users WHERE email_users = ?', [email], async (err, result) => {
            if (err) throw err;
            if (!result[0] || !await bcryptjs.compare(password, result[0].password_users)) {
                return res.json({ status: "error", error: "Niepoprawne hasło lub email" });
            } else {
                const token = jwt.sign({ id: result[0].id_users }, process.env.JWT_SECRET, {
                    expiresIn: process.env.JWT_EXPIRES
                });

                const cookieOptions = {
                    expires: new Date(Date.now() + process.env.COOKIE_EXPIRES * 24 * 60 * 60 * 1000),
                    httpOnly: true
                };
                res.cookie("userRegistered", token, cookieOptions);

                console.log("Ciasteczko ustawione: ", token);  // Debugowanie

                return res.json({ status: "success", redirect: "/home" });
            }
        });
    }
};

module.exports = login;
}

	logout.js
{const logout = (req, res) => {
    res.clearCookie("userRegistered")
    res.redirect("/");
}

module.exports = logout;}

	notifications.js
{const { dbLogins } = require('../routes/db-config');

const getNotification = (req, res) => {
    const notificationId = req.params.id;

    dbLogins.query(
        'SELECT head_notifications, msg_notifications, dispatcher_notifications, noteid_notifications, type_notifications FROM notifications WHERE id_notifications = ?',
        [notificationId],
        (err, result) => {
            if (err) {
                return res.json({ status: 'error', error: 'Błąd pobierania powiadomienia' });
            }
            if (result.length === 0) {
                return res.json({ status: 'error', error: 'Powiadomienie nie istnieje' });
            }
            
            res.json({ status: 'success', notification: result[0] });
        }
    );
};

// Nowa funkcja do aktualizacji statusu powiadomienia na "read"
const markNotificationAsRead = (req, res) => {
    const notificationId = req.params.id;

    dbLogins.query(
        'UPDATE notifications SET status_notifications = "read" WHERE id_notifications = ?',
        [notificationId],
        (err, result) => {
            if (err) {
                return res.json({ status: 'error', error: 'Błąd podczas oznaczania powiadomienia jako przeczytane' });
            }
            return res.json({ status: 'success', success: 'Powiadomienie zostało oznaczone jako przeczytane' });
        }
    );
};

const getReadNotifications = (req, res) => {
    const safeId = req.user.safeid_users;

    dbLogins.query('SELECT id_notifications, head_notifications, date_notifications FROM notifications WHERE user_notifications = ? AND status_notifications = "read"', [safeId], (err, results) => {
        if (err) {
            console.error("Błąd podczas pobierania przeczytanych powiadomień:", err);
            return res.status(500).json({ status: "error", error: "Błąd podczas pobierania przeczytanych powiadomień" });
        }

        res.json({ status: "success", notifications: results });
    });
};




module.exports = { getNotification, markNotificationAsRead, getReadNotifications };
}

	register.js
{const { dbLogins } = require("../routes/db-config");
const bcrypt = require("bcryptjs");

// Funkcja generująca losowy identyfikator składający się z małych i dużych liter, cyfr, oraz znaków # i @
const generateSafeId = () => {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#@';
    let safeId = '';
    for (let i = 0; i < 16; i++) {
        safeId += chars[Math.floor(Math.random() * chars.length)];
    }
    return safeId;
};

// Funkcja sprawdzająca unikalność safeid_users
const isSafeIdUnique = (safeId) => {
    return new Promise((resolve, reject) => {
        dbLogins.query('SELECT safeid_users FROM users WHERE safeid_users = ?', [safeId], (err, result) => {
            if (err) reject(err);
            if (result.length > 0) {
                resolve(false); // SafeId nie jest unikalny
            } else {
                resolve(true); // SafeId jest unikalny
            }
        });
    });
};

const register = async (req, res) => {
    const { email, password: Npassword, firstName, lastName, birthDate } = req.body;

    if (!email || !Npassword || !firstName || !lastName || !birthDate) {
        return res.json({ status: "error", error: "Proszę wypełnić wszystkie pola" });
    } else {
        dbLogins.query('SELECT email_users FROM users WHERE email_users = ?', [email], async (err, result) => {
            if (err) throw err;
            if (result[0]) {
                return res.json({ status: "error", error: "Email już jest w systemie" });
            } else {
                // Hashowanie hasła użytkownika
                const password = await bcrypt.hash(Npassword, 8);

                // Generowanie unikalnego safeId
                let safeId;
                let unique = false;

                // Pętla, która generuje unikalny `safeid_users`, jeśli nie jest unikalny, generuje nowy
                while (!unique) {
                    safeId = generateSafeId();  // Wygeneruj nowy safeId
                    unique = await isSafeIdUnique(safeId);  // Sprawdź, czy jest unikalny
                }

                // Zapisanie nowego użytkownika do bazy danych
                dbLogins.query('INSERT INTO users SET ?', { 
                    email_users: email, 
                    password_users: password,
                    firstname_users: firstName,
                    lastname_users: lastName,
                    dateofbirth_users: birthDate,
                    safeid_users: safeId, // Zapisujemy unikalne safeId
                    type_users: "Normal" // Automatycznie ustawiamy wartość "Normal" dla kolumny type_users
                }, (error, results) => {
                    if (error) throw error;
                    return res.json({ status: "success", success: "Użytkownik został zarejestrowany" });
                });
                
            }
        });
    }
};

module.exports = register;
}

	upload.js
{const path = require('path');
const fs = require('fs');
const multer = require('multer');
const crypto = require('crypto');  // Do generowania bezpiecznych nazw plików
const { dbFiles } = require("../routes/db-config");

// Konfiguracja Multer do przechowywania plików w odpowiednich folderach
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const safeId = req.user.safeid_users; // Zalogowany użytkownik, teraz pobieramy safeid_users
        const userDir = path.join(__dirname, '..', 'data', 'users', safeId);

        // Sprawdź, czy katalog użytkownika (safeid) istnieje, jeśli nie, to go utwórz
        if (!fs.existsSync(userDir)) {
            fs.mkdirSync(userDir, { recursive: true });
            console.log(`Utworzono katalog dla użytkownika z safeid: ${safeId}`);
        }

        cb(null, userDir); // Zapisuj plik w folderze użytkownika na podstawie safeid_users
    },
    filename: (req, file, cb) => {
        const originalName = file.originalname;

        // Generowanie bezpiecznej zaszyfrowanej nazwy pliku przy użyciu funkcji crypto
        const cryptedName = crypto.randomBytes(16).toString('hex') + path.extname(originalName); // Bezpieczna nazwa z rozszerzeniem
        console.log(`Przesyłanie pliku: ${originalName} (zaszyfrowana nazwa: ${cryptedName})`);
        cb(null, cryptedName);
    }
});

const upload = multer({ storage: storage }).single('file');

// Funkcja obsługująca przesyłanie pliku i zapisywanie informacji do bazy
const uploadFile = (req, res) => {
    const safeId = req.user.safeid_users;  // Pobieramy safeid_users zamiast emaila
    console.log(`Rozpoczęto przesyłanie pliku przez użytkownika z safeid: ${safeId}`);

    upload(req, res, (err) => {
        if (err) {
            console.error('Błąd podczas przesyłania pliku:', err);
            return res.json({ status: 'error', error: 'Błąd przesyłania pliku' });
        }

        const originalName = req.file.originalname;
        const cryptedName = req.file.filename;

        // Określenie typu pliku na podstawie rozszerzenia
        const fileType = path.extname(originalName).substring(1); // np. 'txt', 'pdf', 'docx'

        // Zapisz dane pliku do bazy danych sdrive_files, teraz z safeid_users w kolumnie cryptedowner_files
        dbFiles.query(
            'INSERT INTO files (originalname_files, cryptedname_files, cryptedowner_files, filetype_files) VALUES (?, ?, ?, ?)',
            [originalName, cryptedName, safeId, fileType],  // Zapisujemy safeId zamiast zaszyfrowanego emaila
            (err, result) => {
                if (err) {
                    console.error('Błąd zapisu informacji o pliku do bazy danych:', err);
                    return res.json({ status: 'error', error: 'Błąd zapisu w bazie danych' });
                }
                console.log(`Plik ${originalName} został pomyślnie przesłany i zapisany w bazie danych.`);
                return res.json({ status: 'success', success: 'Plik przesłany i zapisany' });
            }
        );
    });
};

module.exports = uploadFile;
}

/data
	/users
/public
	/images
	/js
		deleteFile.js
{function deleteFile(filename) {
    fetch(`/delete/${filename}`, {
        method: 'DELETE',
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            alert(data.success);
            location.reload(); // Odśwież stronę po usunięciu pliku
        } else {
            alert(data.error);
        }
    })
    .catch(err => {
        console.error('Błąd podczas usuwania pliku:', err);
        alert('Wystąpił błąd podczas usuwania pliku.');
    });
}
}

		friends.js
{const form = document.getElementById('friendSearchForm');
let friendModal;

// Nasłuchiwanie na kliknięcie przycisku "Wyświetl"
document.getElementById('showFriendsButton').addEventListener('click', function() {
    fetch('/api/get-friends', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            const friendsList = document.getElementById('friendsList');
            friendsList.innerHTML = ''; // Wyczyść listę

            console.log('Pobrano listę znajomych:', data.friends); // Debug

            // Dodaj znajomych do listy
            data.friends.forEach(friend => {
                const listItem = document.createElement('li');
                listItem.classList.add('list-group-item');
                listItem.innerHTML = `
                    ${friend.firstname_users} ${friend.lastname_users} (${friend.email_users})
                    <button class="btn btn-danger btn-sm float-end" onclick="removeFriend(${friend.id_users})">Usuń</button>
                `;
                friendsList.appendChild(listItem);
            });

            // Pokaż modal
            const friendsModal = new bootstrap.Modal(document.getElementById('friendsModal'));
            friendsModal.show();
        } else {
            console.error('Błąd podczas pobierania listy znajomych:', data.error); // Debug
        }
    })
    .catch(err => {
        console.error('Błąd podczas pobierania znajomych:', err); // Debug
    });
});

// Funkcja usuwania znajomego
function removeFriend(friendId) {
    console.log('Próba usunięcia znajomego o ID:', friendId); // Debug

    if (confirm("Czy na pewno chcesz usunąć tego znajomego?")) {
        fetch(`/api/remove-friend`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ friendId })  // Przekazujemy tylko ID znajomego
        })
        .then(response => response.json())
        .then(data => {
            console.log('Otrzymane dane z serwera po próbie usunięcia znajomego:', data); // Debug

            if (data.status === 'success') {
                alert('Znajomy został usunięty.');
                location.reload(); // Odśwież stronę po usunięciu
            } else {
                alert('Błąd podczas usuwania znajomego.');
            }
        })
        .catch(err => {
            console.error('Błąd podczas usuwania znajomego:', err); // Debug
        });
    }
}



form.addEventListener('submit', function(event) {
    event.preventDefault();
    
    const friendEmail = document.getElementById('friendEmail').value;
    console.log('Formularz wyszukiwania znajomego został wysłany. Email:', friendEmail);
    
    fetch(`/api/search-friend`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: friendEmail })
    })
    .then(response => response.json())
    .then(data => {
        console.log('Dane z serwera:', data);

        if (data.status === 'success') {
            // Sprawdź, czy elementy istnieją
            const friendModalLabel = document.getElementById('friendModalLabel');
            const friendEmailInfo = document.getElementById('friendEmailInfo');
            const inviteButton = document.getElementById('inviteButton');

            // Sprawdź, czy wszystkie elementy istnieją zanim ich użyjesz
            if (!friendModalLabel || !friendEmailInfo || !inviteButton) {
                console.error('Brakuje jednego lub więcej elementów modala');
                return;
            }

            // Ustaw dane w modalu
            friendModalLabel.textContent = "Znaleziono użytkownika";
            friendEmailInfo.textContent = `Użytkownik: ${data.user.email_users}`;
            
            // Dodaj funkcję do przycisku zaproszenia
            inviteButton.onclick = function() {
                inviteFriend(data.user.id_users);
            };

            // Otwórz modal
            friendModal = new bootstrap.Modal(document.getElementById('friendModal'));
            friendModal.show();
        } else {
            console.error(`Błąd wyszukiwania użytkownika: ${data.error}`);
        }
    })
    .catch(err => {
        console.error('Błąd wyszukiwania znajomego:', err);
    });
});

function inviteFriend(friendId) {
    console.log('Wysyłanie zaproszenia do znajomego. ID:', friendId);
    
    fetch(`/api/invite-friend`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ friendId: friendId })
    })
    .then(response => response.json())
    .then(data => {
        console.log('Otrzymane dane po zaproszeniu:', data);
        
        if (data.status === 'success') {
            console.log('Znajomy został zaproszony pomyślnie.');
            friendModal.hide(); // Zamknij modal po zaproszeniu znajomego
        } else if (data.status === 'error' && data.error === 'Użytkownicy są już znajomymi.') {
            // Zamknij modal, a następnie pokaż alert, że użytkownicy są już znajomymi
            friendModal.hide(); 
            alert('Użytkownicy są już znajomymi.');
        } else {
            console.error(`Błąd zapraszania znajomego: ${data.error}`);
        }
    })
    .catch(err => {
        console.error('Błąd zapraszania znajomego:', err);
    });
}
}

		login.js
{const form = document.getElementById("loginForm");

form.addEventListener("submit", (event) => {
    event.preventDefault();  
    const login = {
        email: document.getElementById("email").value,
        password: document.getElementById("password").value
    };
    fetch("/api/login", {
        method: "POST",
        body: JSON.stringify(login),
        headers: {
            "Content-Type": "application/json"
        }
    }).then(res => res.json())
        .then(data => {
            console.log("Odpowiedź z backendu:", data);  // Dodaj to do debugowania
            if (data.status === "error") {
                document.getElementById("success").style.display = "none";
                document.getElementById("error").style.display = "block";
                document.getElementById("error").innerText = data.error;
            } else {
                window.location.href = data.redirect;
            }
        });
    
});
}

		notifications.js
{function showNotificationContent(notificationId) {
    fetch(`/api/notification/${notificationId}`)
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                const notificationContentLabel = document.getElementById('notificationContentLabel');
                const notificationContent = document.getElementById('notificationContent');
                const friendRequestActions = document.getElementById('friendRequestActions');

                // Ustaw tytuł i treść powiadomienia
                notificationContentLabel.textContent = 'Powiadomienie';
                notificationContent.innerHTML = `<p>${data.notification.msg_notifications}</p>`;

                // Sprawdź, czy to zaproszenie do znajomych
                if (data.notification.type_notifications === 'friend_request') {
                    friendRequestActions.style.display = 'block';
                    document.getElementById('acceptButton').onclick = function() {
                        respondToFriendRequest(data.notification.noteid_notifications, 'accept');
                        updateNotificationStatus(notificationId); // Zmieniamy status po akceptacji
                        location.reload();  // Odświeżenie strony po zaakceptowaniu
                    };
                    document.getElementById('denyButton').onclick = function() {
                        respondToFriendRequest(data.notification.noteid_notifications, 'deny');
                        updateNotificationStatus(notificationId); // Zmieniamy status po odmowie
                        location.reload();  // Odświeżenie strony po odrzuceniu
                    };
                } else {
                    friendRequestActions.style.display = 'none';
                }

                // Pokaż modal z powiadomieniem
                let notificationModal = new bootstrap.Modal(document.getElementById('notificationContentModal'));
                notificationModal.show();

                // Zmieniamy status powiadomienia na "read" po kliknięciu "Zamknij"
                document.querySelector('.btn-secondary').onclick = function() {
                    updateNotificationStatus(notificationId);
                    location.reload();  // Odświeżenie strony po kliknięciu "Zamknij"
                };
            } else {
                alert('Błąd podczas wyświetlania powiadomienia');
            }
        })
        .catch(err => {
            console.error('Błąd podczas pobierania powiadomienia:', err);
        });
}

// Funkcja zmieniająca status powiadomienia na "read"
function updateNotificationStatus(notificationId) {
    fetch(`/api/notification/${notificationId}/read`, {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            console.log(`Powiadomienie ${notificationId} zostało oznaczone jako przeczytane`);
        } else {
            console.error('Błąd podczas aktualizacji statusu powiadomienia:', data.error);
        }
    })
    .catch(err => {
        console.error('Błąd podczas aktualizacji statusu powiadomienia:', err);
    });
}

document.getElementById('readNotificationsButton').addEventListener('click', function() {
    fetch('/api/read-notifications')
        .then(response => response.json())
        .then(data => {
            const readNotificationsList = document.getElementById('readNotificationsList');
            readNotificationsList.innerHTML = ''; // Wyczyszczenie starej zawartości

            if (data.status === 'success') {
                const notifications = data.notifications;

                if (notifications.length > 0) {
                    notifications.forEach(notification => {
                        const listItem = document.createElement('li');
                        listItem.classList.add('list-group-item', 'd-flex', 'justify-content-between', 'align-items-center');
                        
                        const notificationContent = `
                            <div>
                                <strong>${notification.head_notifications}</strong> <br>
                                <small>${new Date(notification.date_notifications).toLocaleDateString('pl-PL', { day: '2-digit', month: '2-digit', year: 'numeric' })}</small>
                            </div>`;
                        
                        listItem.innerHTML = notificationContent;
                        readNotificationsList.appendChild(listItem);
                    });
                } else {
                    const emptyMessage = document.createElement('li');
                    emptyMessage.classList.add('list-group-item');
                    emptyMessage.textContent = 'Nie masz przeczytanych powiadomień';
                    readNotificationsList.appendChild(emptyMessage);
                }
            } else {
                console.error('Błąd: ', data.error);
            }
        })
        .catch(err => {
            console.error('Błąd podczas pobierania przeczytanych powiadomień:', err);
        });
});
}

		register.js
{const form = document.getElementById("registerForm");

form.addEventListener("submit", (event) => {
    event.preventDefault(); 
    const register = {
        email: document.getElementById("email").value,
        password: document.getElementById("password").value,
        firstName: document.getElementById("firstName").value,
        lastName: document.getElementById("lastName").value,
        birthDate: document.getElementById("birthDate").value
    };

    fetch("/api/register", {
        method: "POST",
        body: JSON.stringify(register),
        headers: {
            "Content-Type": "application/json"
        }
    }).then(res => res.json())
        .then(data => {
            if (data.status === "error") {
                document.getElementById("success").style.display = "none";
                document.getElementById("error").style.display = "block";
                document.getElementById("error").innerText = data.error;
            } else {
                document.getElementById("error").style.display = "none";
                document.getElementById("success").style.display = "block";
                document.getElementById("success").innerText = data.success;
            }
        });
});
}

		respodtToFriendRequest.js
{function respondToFriendRequest(noteId, action) {
    fetch(`/api/respond-friend-request`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ noteId, action })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            alert(data.success);
            location.reload(); // Odśwież stronę po odpowiedzi
        } else {
            alert(data.error);
        }
    })
    .catch(err => {
        console.error('Błąd podczas odpowiedzi na zaproszenie do znajomych:', err);
        alert('Wystąpił błąd podczas odpowiedzi na zaproszenie.');
    });
}}

		showfile.js
{let currentHtmlFilePath = null;  // Zmienna do przechowywania ścieżki pliku .html

function showFileContent(filename) {
    console.log(`Rozpoczęto wczytywanie pliku: ${filename}`);

    fetch(`/show/${filename}`)  // Używamy zaszyfrowanej nazwy pliku
    .then(response => response.json())
    .then(data => {
        console.log('Otrzymane dane:', data);

        // Przechowujemy ścieżkę do pliku .html, jeśli plik jest typu .docx
        currentHtmlFilePath = data.htmlFilePath ? data.htmlFilePath : null;

        const fileContentLabel = document.getElementById('fileContentLabel');
        const fileContent = document.getElementById('fileContent');

        if (!fileContentLabel || !fileContent) {
            throw new Error('Elementy modalne nie zostały załadowane na stronę');
        }

        // Ustawiamy dynamicznie nazwę pliku jako tytuł okna modalnego
        fileContentLabel.innerText = data.originalName;

        // Ustawiamy zawartość jako HTML
        fileContent.innerHTML = data.content;

        let fileContentModal = new bootstrap.Modal(document.getElementById('fileContentModal'));
        fileContentModal.show();
    })
    .catch(err => {
        console.error('Błąd podczas wczytywania pliku:', err);
        alert('Nie udało się wczytać pliku');
    });
}

// Funkcja wywoływana po zamknięciu modalnego okna
function removeHtmlCopy() {
    if (currentHtmlFilePath) {
        fetch(`/remove-html`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ htmlFilePath: currentHtmlFilePath })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                console.log('Plik .html został usunięty.');
            } else {
                console.error('Błąd podczas usuwania pliku .html:', data.error);
            }
        })
        .catch(err => {
            console.error('Błąd podczas usuwania pliku .html:', err);
        });
    }
    currentHtmlFilePath = null;  // Zresetowanie ścieżki po usunięciu pliku
}

// Dodaj nasłuchiwanie na zamknięcie modalnego okna
document.getElementById('fileContentModal').addEventListener('hidden.bs.modal', removeHtmlCopy);
}

		upload.js
{const uploadForm = document.getElementById('uploadForm');

uploadForm.addEventListener('submit', (event) => {
    event.preventDefault();
    
    const fileInput = document.getElementById('file');
    const formData = new FormData();
    formData.append('file', fileInput.files[0]);

    fetch('/api/upload', {
        method: 'POST',
        body: formData,
    }).then(res => res.json())
      .then(data => {
        if (data.status === 'error') {
            document.getElementById('uploadError').innerText = data.error;
        } else {
            document.getElementById('uploadSuccess').innerText = data.success;
            location.reload(); // Odśwież stronę po usunięciu pliku
        }
    });
});
}

/routes
	db-config.js
	{const mysql = require("mysql");
const dotenv = require("dotenv").config();

const dbLogins = mysql.createConnection({
    host: process.env.DATABASE_HOST,
    user: process.env.DATABASE_USER,
    password: process.env.DATABASE_PASSWORD,
    database: process.env.DATABASE_LOGINS
});

const dbFiles = mysql.createConnection({
    host: process.env.DATABASE_HOST,
    user: process.env.DATABASE_USER,
    password: process.env.DATABASE_PASSWORD,
    database: process.env.DATABASE_FILES
});

module.exports = { dbLogins, dbFiles };
}
	
	pages.js
	{const express = require("express");
const loggedIn = require("../controllers/loggedIn");
const logout = require("../controllers/logout");
const downloadFile = require("../controllers/download");
const deleteFile = require("../controllers/deleteFile");
const { showFileContent, removeHtmlFile } = require("../controllers/fileController"); // Import kontrolera plików
const { getNotification, markNotificationAsRead, getReadNotifications } = require('../controllers/notifications');
const { dbFiles } = require("../routes/db-config");
const { dbLogins } = require("../routes/db-config");
const { respondToFriendRequest } = require("../controllers/friends");
const { getFriends, removeFriend } = require('../controllers/friends');
const router = express.Router();

// Trasa do wyświetlania zawartości pliku
router.get("/show/:filename", loggedIn, showFileContent);

// Trasa do usuwania plików HTML
router.post("/remove-html", removeHtmlFile);

// Trasa do usuwania plików z weryfikacją, czy użytkownik jest zalogowany
router.delete("/delete/:filename", loggedIn, deleteFile);

// Trasa do pobierania plików z weryfikacją, czy użytkownik jest zalogowany
router.get("/download/:filename", loggedIn, downloadFile);

// Trasa do obsługi powiadomień
router.get('/api/notification/:id', loggedIn, getNotification);
router.post('/api/notification/:id/read', markNotificationAsRead);

// Nowa trasa do wyświetlania przeczytanych powiadomień
router.get('/api/read-notifications', loggedIn, getReadNotifications);

// Nowa trasa do obsługi akceptacji/odrzucenia zaproszeń do znajomych
router.post("/api/respond-friend-request", loggedIn, respondToFriendRequest);

// Trasy obsługi znajomych - lista i usuwanie
router.get('/api/get-friends', loggedIn, getFriends);
router.post('/api/remove-friend', loggedIn, removeFriend);

// Trasa do strony "home" z weryfikacją, czy użytkownik jest zalogowany
router.get('/home', loggedIn, (req, res) => {
    if (req.user) {
        const safeId = req.user.safeid_users;

        // Pobierz listę plików przypisanych do użytkownika na podstawie safeid_users
        dbFiles.query('SELECT originalname_files, cryptedname_files FROM files WHERE cryptedowner_files = ?', [safeId], (err, files) => {
            if (err) throw err;

            // Pobierz tylko nieprzeczytane powiadomienia
            dbLogins.query('SELECT id_notifications, head_notifications, date_notifications FROM notifications WHERE user_notifications = ? AND status_notifications = "unread"', [safeId], (err, notifications) => {
                if (err) throw err;

                // Przekaż listę plików i powiadomień do widoku home.ejs
                res.render('home', { user: req.user, files: files, notifications: notifications });
            });
        });
    } else {
        res.redirect('/login');
    }
});

// Inne trasy...
router.get("/", (req, res) => {
    res.render("login");
});

router.get("/register", (req, res) => {
    res.render("register");
});

router.get("/login", (req, res) => {
    res.render("login");
});

router.post("/logout", logout);

module.exports = router;
}
	
/views
	home.ejs
{}

	login.ejs
{}

	register.ejs
{}

	welcome.ejs
{}

.env
{DATABASE_HOST = localhost
DATABASE_USER = sdrive
DATABASE_PASSWORD = 11tata11
DATABASE_LOGINS = sdrive_logins
DATABASE_FILES = sdrive_files
JWT_SECRET = 743BTG8therwwifhbASDa04184SFD12310ei90QWEqui
JWT_EXPIRES = 90d
COOKIE_EXPIRES = 90}

index.js
{const express = require("express");
const { dbLogins } = require("./routes/db-config");
const { dbFiles } = require("./routes/db-config");
const app = express();
const cookie = require("cookie-parser");
const path = require('path');
const PORT = process.env.PORT || 3000;

app.use("/js", express.static(path.join(__dirname, "/public/js")));
app.use("/css", express.static(path.join(__dirname, "/public/css")));
app.use("/data", express.static(path.join(__dirname, "/data")));
app.use("/images", express.static(path.join(__dirname, "/public/images"))); // Dodano ścieżkę do plików z obrazami

app.use(cookie());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.set("view engine", "ejs");
app.set("views", "./views");

app.use("/", require("./routes/pages"));
app.use("/api", require("./controllers/auth")); // Obsługa logowania/rejestracji

app.listen(PORT, () => {
    console.log(`Serwer działa na porcie ${PORT}`);
});

//BAZY DANYCH

// UŻYTKOWNICY
dbLogins.connect((err) => {
    if (err) {
        console.error("Błąd połączenia z bazą danych logowania:", err);
    } else {
        console.log("Połączono z bazą danych logowania");
    }
});

// PLIKI
dbFiles.connect((err) => {
    if (err) {
        console.error("Błąd połączenia z bazą danych plików:", err);
    } else {
        console.log("Połączono z bazą danych plików");
    }
});
}

